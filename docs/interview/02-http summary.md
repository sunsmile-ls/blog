#### HTTP/1：HTTP性能优化

* 超文本传输协议 HTTP/0.9

简介：

1. 准备好ip和端口号建立tcp链接
2. 发送请求头信息`GET /index.html`
3. 读取文件，并以ascii码返回

#### 被浏览器推动的 HTTP/1.0

**背景**： 1994 年底出现了拨号上网服务，同年网景又推出一款浏览器，从此万维网就不局限于学术交流了，而是进入了高速的发展阶段。

**需求**： 

* 支持多种类型的文件下载是 HTTP/1.0 的一个核心诉求 【引入了请求头响应头的信息】
* 单个文件变的越来越大，需要压缩【提供了`accept-encoding: gzip, deflate, br`】
* 万维网是全球范围支持，所以需要国际化【`accept-language: zh-CN,zh`】

```
# 响应头信息
content-encoding: br
content-type: text/html; charset=UTF-8
```

**衍生需求**：

*  引入了请求头响应头的信息
* 减少服务器压力【提供了 Cache 机制，用来缓存已经下载过的数据。】
* 服务器需要统计客户端的基础信息【`HTTP/1.0 的请求头中还加入了用户代理的字段`】

#### 缝缝补补的 HTTP/1.1

1. **改进持久连接**

HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。

2. **不成熟的http管线化**

持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。**队头阻塞**

3. **提供虚拟主机的支持**

HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。

4. **对动态生成的内容提供了完美支持**

HTTP/1.1 通过引入 **Chunk transfer** 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。

5. **客户端 Cookie、安全机制**

##### HTTP/1.1 为网络效率做了大量的优化，最核心的有如下三种方式：

1. 增加了持久连接；
2. 浏览器为每个域名最多同时维护 6 个 TCP 持久连接；
3. 使用 CDN 的实现域名分片机制。

##### HTTP/1.1 的主要问题

* **第一个原因，TCP 的慢启动。**

刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。

* **第二个原因，同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽**

一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度

* **第三个原因，HTTP/1.1 队头阻塞的问题。**

#### HTTP/2 的多路复用

解决：**一个域名只使用一个 TCP 长连接和消除队头阻塞问题。**

<img src="\images\86cdf01a3af7f4f755d28917e58aae6a.png" style="zoom:50%;" />

* 首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。
* 这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。
* 然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。
* 同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。
* 浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。

#### HTTP/2 其他特性

1. 可以设置请求的优先级

HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求

2. 服务器推送

服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，

3. 头部压缩

## TCP 的问题

#### TCP 的队头阻塞

* http/1.1

  有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来

* HTTP/2

  HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。

  **随着丢包率的增加，HTTP/2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。**

#### TCP 建立连接的延时

* TCP 的握手过程也是影响传输效率的一个重要因素

把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT

1. 在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。
2. 进行 TLS 连接，TLS 有两个版本——TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致是需要 1～2 个 RTT

那既然有这两个缺点，改掉不是就可以了？**答案是很困难**， 原因有二

1. 中间设备的僵化 【路由器、防火墙、NAT、交换机等，不理解包的内容，数据就会被丢弃掉】
2. 操作系统也是导致 TCP 协议僵化【TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。通常操作系统的更新都滞后于软件的更新】

### QUIC 协议

<img src="\images\0bae470bb49747b9a59f9f4bb496a9c6.png" style="zoom:50" />

* 实现了类似 TCP 的流量控制、传输可靠性的功能。

提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性

* 集成了 TLS 加密功能

QUIC 使用的是 TLS1.3，减少了握手所花费的 RTT 个数。

* 实现了 HTTP/2 中的多路复用功能 【**之前是只能连接一路，现在可以连接多路**】

和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。

* 实现了快速握手功能

QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接

#### HTTP/3 的挑战通过上面的分析

* 第一，从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。
* 第二，部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。
* 第三，中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。

